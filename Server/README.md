### 游戏服
> 启动类ServerBootstrap

#### 登录游戏服流程
1. 客户端发送登录的http请求到登录服，登陆服将PlayerPlatformData[含有ticket(登录服在每次请求登录时生成新的)]保存到redis中，
并响应客户端LoginResponse[包含ip、port、ticket]
2. 客户端根据登录服响应的ip、端口等用tcp协议连接对应的游戏服
3. 客户端发送ConnectionReq协议包给游戏服，服务器响应ConnectionRsp
4. 客户端发送LoginReq协议给游戏服处理登录

```
游戏服响应给客户端LoginRsp

1.如果需要注册，客户端发送RandomNameReq协议包给游戏服，服务器响应RandomNameRsp
客户端发送RegisterReq协议包给游戏服，服务器处理注册逻辑，并响应RegisterRsp注册成功，
同时在游戏服中直接登录成功并推送玩家信息PlayerDataPush给客户端，至此登录成功。
（注册时的ticket从redis获取并保存到PlayerDo）

2.已经注册账号，直接登录成功并推送玩家信息PlayerDataPush给客户端，至此登录成功
（ticket从客户端请求获得，如果与PlayerBo中原先的ticket相同，会走重连逻辑）
登录会保存新的ticket到PlayerDo

（客户端持有的ticket是登录服生成的。所以会与redis中相同，redis中PlayerPlatformData是登录凭证）
```
#### 连接处理
```
channelActive:
实例化DSession并且绑定当前channel，同时注册channel的关闭监听[channel关闭会调用DSession的close方法(服务端断开连接也是调用此方法走登出流程)]
同时channel也绑定DSession
channel绑定MessageActor(具体类型在启动类参数中指定),游戏服直接创建PlayerActor且绑定DSession
即每次连接成功都是新的DSession和PlayerActor

channelRead:
从channel获取DSession，DSession获取PlayerActor并分发处理请求

重连：

新的连接成功后，在登录过程中调用PlayerActor#auth方法(已将旧的踢下线)
0.PlayerActor绑定playerId
1.创建PlayerDataLoader, PlayerActor绑定PlayerDataLoader，且注册到DataLoaderManager
2.循环调度发起PlayerActor与玩法服的跨服连接心跳
3.循环调度发起PlayerActor与客户端的连接心跳
登录成功会给DSession注册关闭监听[服务端登出逻辑、看退出原因给10分钟重连时间、推送给客户端],
这个监听是在Dession的close方法中调用，即客户端断开连接或者服务端主动调用退出都会执行到这个监听器，调用完后会确保断开连接

dataSupport从数据库中获取PlayerBo(如果时同账号肯定与原先不同对象)
如果数据库的PlayerBo与此次客户端带的ticket相同走重连流程。

向UserOnlineManager中传入playerId,当前连接绑定的PlayerActor进入重连操作
将当前channel绑定旧的PlayerActor，将旧的PlayerActor绑定新的DSession
并将新的PlayerActor中的消息全部加入旧的PlayerActor。
销毁新的PlayerActor,之后用的都是旧的PlayerActor

新PlayerActor的PlayerDataLoader会在重连成功后走一遍入库流程再解绑DataLoaderManager
旧PlayerActor的PlayerDataLoader会在其退出时走一遍入库流程再解绑，如果重连成功后重新注册到DataLoaderManager
```
